<!DOCTYPE html>
<html lang="ja">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<title>集計ちゃん by Popolo v3.5.4e</title>
<style>
  body { font-family: sans-serif; padding: 20px; }
  .table-wrapper { overflow-x: auto; }
  table { 
      border-collapse: collapse; 
      table-layout: fixed;
      width: max-content;
  }
  th, td { 
      border: 1px solid #999; 
      padding: 5px 10px; 
      text-align: center; 
      white-space: nowrap; 
      width: 80px; 
  }
  th { background-color: #eee; cursor: pointer; }
  .dns { color: red; font-weight: bold; }
  .cut { color: blue; font-weight: bold; }

  button {
      font-size: 1.2em;
      padding: 14px 24px;
      margin: 5px 5px;
      min-width: 140px;
      cursor: pointer;
      border-radius: 6px;
      border: 1px solid #666;
      background-color: #f0f0f0;
  }
  button:active { background-color: #ddd; }

  select, input[type="text"], input[type="number"] {
      font-size: 1.1em;
      padding: 10px;
      min-width: 140px;
      margin: 5px 5px;
      border-radius: 5px;
      border: 1px solid #999;
      box-sizing: border-box;
  }

  input[type="file"] { display: none; }

  /* ボタン色 */
  #handleCSVBtn { background-color: #4CAF50; color: white; }  /* 緑 */
  #downloadCSVBtn { background-color: #2196F3; color: white; } /* 青 */
  #recalcBtn { background-color: #FF9800; color: white; }      /* オレンジ */
  #manualHeatBtn { background-color: #9C27B0; color: white; }  /* 紫 */

  /* モーダル */
  #manualHeatModal {
      display:none; 
      position:fixed; 
      top:10%; left:50%; transform:translateX(-50%);
      border:1px solid #999; padding:10px; background:#fff;
      z-index: 1000;
      max-height: 80%;
      overflow-y: auto;
  }
  #manualHeatInputs div { margin-bottom:5px; }
</style>
</head>
<body>

<h2>集計ちゃん  <span style="font-size:0.7em;">by Popolo v3.5.4e</span></h2>

<label>種目: 
  <select id="discipline">
    <option value="wind">ウインドサーフィン</option>
    <option value="yacht">ウイングフォイル/ヨット</option>
    
  </select>
</label>
<br><br>

<label>カット設定（ヒート数を入力）:</label><br>
1カットヒート: <input type="number" id="cut1Heat" placeholder="例: 4" style="width:80px; text-align:center;">
2カットヒート: <input type="number" id="cut2Heat" placeholder="例: 8" style="width:80px; text-align:center;">
<br><br>

<label>参加選手番号（カンマ区切り）:</label>
<input type="text" id="participantList" placeholder="001,002,003,004">
<span id="participantCount" style="margin-left:10px;">0名</span>
<br>

<!-- 参加者CSV読み取り -->
<button id="loadParticipantBtn">参加選手リストの読取</button>
<span id="participantFileName">未選択</span>

<input type="file" id="participantCSV" accept=".csv">

<br><br>

<button id="csvFileBtn">ヒート結果を読取</button>
<input type="file" id="csvFile" accept=".csv">
<span id="heatFileName">未選択</span>
<BR>（読取後、↓のヒート追加ボタンで集計表に反映)
<br><br>


<button id="handleCSVBtn" onclick="handleCSV()">ヒート追加（CSV）</button>
<button id="manualHeatBtn" onclick="openManualHeat()">ヒート手入力</button>
<BR>(確定ボタンで集計表に反映)
<button id="downloadCSVBtn" onclick="downloadCSV()">総合結果をCSV出力</button>
<button id="recalcBtn" onclick="updateTable()">再計算</button>

<div id="tableContainer"></div>

<!-- モーダル -->
<div id="manualHeatModal">
    <h3>手入力ヒート（順位→番号入力）</h3>
    <div id="manualHeatInputs"></div>
    <button id="manualAddBtn">追加</button>
    <button onclick="submitManualHeat()">確定</button>
    <button onclick="closeManualHeatModal()">キャンセル</button>
</div>

<script>
let results = {};        // { "001": [heat1, heat2, ...], ... }
let heats = [];          // ["Heat1","Heat2",...]
let cutSettings = {};
let participants = [];   // 表示対象の参加者リスト（順序保持）
let seriesCount = 0;
let displayOrder = [];   // 表示順の配列（ソート用）
let currentSortAsc = true;

// ---------- ヘルパ: 参加者テキストから内部状態に反映 ----------
function applyParticipantsFromInput(){
    const participantText = document.getElementById('participantList').value.trim();
    if(!participantText){
        participants = [];
        displayOrder = [];
        seriesCount = 0;
        document.getElementById('participantCount').textContent = `0名`;
        return;
    }

    const updated = participantText.split(',').map(s=>s.trim()).filter(s=>s!=='');
    // 新しい seriesCount を計算（参加者数）
    const newSeriesCount = updated.length;

    // 保持しておきたい既存 results は残す。無ければ初期化（既存ヒート数に合わせる）
    const existingHeatCount = heats.length;
    updated.forEach(id=>{
        if(!results[id]){
            // 新規参加者は既存ヒート分を DNS 値で埋める
            const fillVal = newSeriesCount + 1;
            results[id] = Array(existingHeatCount).fill(fillVal);
        } else {
            // 既存配列が既存ヒート数より短ければ埋める（稀なケース）
            while(results[id].length < existingHeatCount){
                results[id].push(newSeriesCount + 1);
            }
        }
    });

    // participants と displayOrder を更新（順序は入力の順）
    participants = updated.slice();
    displayOrder = participants.slice();
    seriesCount = newSeriesCount;

    // 参加者数表示
    document.getElementById('participantCount').textContent = `${participants.length}名`;

    // 表を更新して反映
    updateTable();
}

// ---------- 参加者CSV読み取り ----------
document.getElementById('loadParticipantBtn').addEventListener('click', () => {
    document.getElementById('participantCSV').click();
});
document.getElementById('participantCSV').addEventListener('change', (ev) => {
    const fileInput = ev.target;
    if(!fileInput.files.length){ alert('CSVを選択してください'); return; }
    document.getElementById('participantFileName').textContent = fileInput.files[0].name;

    const reader = new FileReader();
    reader.onload = function(e){
        const lines = e.target.result.split(/\r?\n/).map(l=>l.trim()).filter(l=>l!=='');
        if(lines.length < 2){ alert('CSVの内容が不十分です'); return; }
        const arr = [];
        for(let i=1;i<lines.length;i++){
            const cols = lines[i].split(',');
            if(cols.length<1) continue;
            const number = cols[0].trim();
            if(number) arr.push(number);
        }
        document.getElementById('participantList').value = arr.join(',');
        applyParticipantsFromInput();
    };
    reader.readAsText(fileInput.files[0], 'utf-8');
    // reset input so same file can be re-selected if needed
    fileInput.value = '';
});

// 参加者テキストを直接編集したときに適用（Enter/Blurで反映）
const participantListInput = document.getElementById('participantList');
participantListInput.addEventListener('blur', applyParticipantsFromInput);
participantListInput.addEventListener('keydown', (e)=>{
    if(e.key === 'Enter'){
        e.preventDefault();
        applyParticipantsFromInput();
        participantListInput.blur();
    }
});

// ---------- ヒートCSV 選択ボタン / ファイル名表示 ----------
document.getElementById('csvFileBtn').addEventListener('click', () => {
    document.getElementById('csvFile').click();
});
document.getElementById('csvFile').addEventListener('change', (ev) => {
    const fi = ev.target;
    document.getElementById('heatFileName').textContent = fi.files.length>0 ? fi.files[0].name : "未選択";
});

// ---------- CSV処理（ヒート追加） ----------
function handleCSV(){
    const fileInput = document.getElementById('csvFile');
    if(!fileInput.files.length){ alert('CSVを選択してください'); return; }

    // 参加者は必ず participantList の内容をベースにする（編集後の内容が反映される）
    applyParticipantsFromInput();
    if(participants.length === 0){ alert('参加選手番号を入力してください'); return; }

    // ensure results has entries for all participants (applyParticipantsFromInput already did this)
    // read file
    const reader = new FileReader();
    reader.onload = function(e){ parseCSV(e.target.result); updateTable(); };
    reader.readAsText(fileInput.files[0], 'utf-8');

    // reset file input so same file can be re-selected later
    fileInput.value = '';
}

// ---------- CSV解析（既存仕様を踏襲） ----------
function parseCSV(text){
    const lines = text.trim().split(/\r?\n/);
    if(lines.length < 2) return;
    const heatName = "Heat" + (heats.length + 1);
    heats.push(heatName);
    const heatPoints = {};
    for(let i=1;i<lines.length;i++){
        const cols = lines[i].split(',');
        if(cols.length < 3) continue;
        const rankStr = cols[1].trim();
        const colorNumber = cols[2].trim();
        if(!participants.includes(colorNumber)) continue;
        const rank = parseInt(rankStr,10);
        heatPoints[colorNumber] = !isNaN(rank) ? rank : (seriesCount + 1);
    }
    // push results for all participants (fill DNS where absent)
    participants.forEach(name=>{
        if(!results[name]) results[name] = Array(heats.length - 1).fill(seriesCount + 1);
        results[name].push( heatPoints[name] !== undefined ? heatPoints[name] : (seriesCount + 1) );
    });
}

// ---------- 手入力ヒートモーダル ----------
let manualNextRank = 1;
function openManualHeat(){
    // ensure participants up-to-date
    applyParticipantsFromInput();
    if(participants.length === 0){ alert('参加者リストが空です'); return; }
    manualNextRank = 1;
    const container = document.getElementById('manualHeatInputs');
    container.innerHTML = '';
    addManualRankInput();
    document.getElementById('manualHeatModal').style.display = 'block';
}
function addManualRankInput(){
    const container = document.getElementById('manualHeatInputs');
    const div = document.createElement('div');
    div.innerHTML = `${manualNextRank}位: <input type="text" class="manualRankInput" placeholder="選手番号">`;
    container.appendChild(div);
    const input = div.querySelector('input');
    input.focus();
    // Enter should create next rank input instead of immediately submitting
    input.addEventListener('keydown', e=>{
        if(e.key === 'Enter'){
            e.preventDefault();
            // if value present, add next rank input; else ignore
            if(input.value.trim()!==''){
                addManualRankInput();
            }
        }
    });
    manualNextRank++;
}
document.getElementById('manualAddBtn').addEventListener('click', addManualRankInput);

function submitManualHeat(){
    const inputs = Array.from(document.querySelectorAll('.manualRankInput'));
    if(inputs.length === 0) return;
    // create new heat
    const heatName = "Heat" + (heats.length + 1);
    heats.push(heatName);
    const heatPoints = {};
    // ensure results arrays exist for all participants and have proper length before push
    participants.forEach(p=>{
        if(!results[p]) results[p] = Array(heats.length - 1).fill(seriesCount + 1);
        while(results[p].length < heats.length - 1) results[p].push(seriesCount + 1);
    });
    // inputs correspond top->down = 1位,2位...
    inputs.forEach((input, idx)=>{
        const val = input.value.trim();
        if(val && participants.includes(val)){
            heatPoints[val] = idx + 1;
        }
    });
    participants.forEach(p=>{
        results[p].push( heatPoints[p] !== undefined ? heatPoints[p] : (seriesCount + 1) );
    });
    updateTable();
    closeManualHeatModal();
}
function closeManualHeatModal(){ document.getElementById('manualHeatModal').style.display = 'none'; }

// ---------- ネットポイント計算（既存ロジック保持） ----------
function getCutCount(heatCount){
    let count = 0;
    for(let key of Object.keys(cutSettings).sort((a,b)=>a-b)){
        if(heatCount >= key) count = cutSettings[key];
    }
    return count;
}
function calculateNetPoints(){
    let netResults = {};
    const discipline = document.getElementById('discipline').value;
    for(let name of participants){
        let points = (results[name] || []).slice();
        let cutCount = getCutCount(points.length);
        let sortedForCut = points.map((p,i)=>({p,i})).sort((a,b)=>b.p - a.p);
        let cuts = [], keptPoints = [], cutIndices = new Set();
        if(cutCount>0){
            for(let i=0;i<cutCount;i++){ if(sortedForCut[i]) cutIndices.add(sortedForCut[i].i); }
        }
        let totalPoints = 0;
        for(let i=0;i<points.length;i++){
            totalPoints += points[i];
            if(cutIndices.has(i)){ cuts.push(points[i]); } else { keptPoints.push(points[i]); }
        }
        let netPoints = totalPoints - cuts.reduce((a,b)=>a+b,0);
        let cutsSorted = cuts.slice().sort((a,b)=>a-b);
        let allPointsSorted = points.slice().sort((a,b)=>a-b);
        let allPointsReversed = points.slice().reverse();
        keptPoints.sort((a,b)=>a-b);
        netResults[name] = { points, cuts: cuts.sort((a,b)=>b-a), net: netPoints, total: totalPoints, discipline, keptPoints, cutsSorted, allPointsSorted, allPointsReversed };
    }
    return netResults;
}

// ---------- 表更新 ----------
function updateTable(){
    cutSettings = {};
    const cut1 = parseInt(document.getElementById('cut1Heat').value);
    const cut2 = parseInt(document.getElementById('cut2Heat').value);
    if(!isNaN(cut1)) cutSettings[cut1] = 1;
    if(!isNaN(cut2)) cutSettings[cut2] = 2;

    const netResults = calculateNetPoints();
    let html = "<table id='resultsTable'><tr>";
    html += "<th onclick='sortTableByColumn(0)'>順位</th><th>選手名</th>";
    heats.forEach((h,i)=> html += `<th onclick="deleteHeat(${i})">${h}</th>`);
    html += "<th>カット前合計</th>";
    let maxCut = Math.max(...Object.values(cutSettings),0);
    for(let i=1;i<=maxCut;i++) html += `<th>カット${i}</th>`;
    html += "<th>Net</th></tr>";

    displayOrder.forEach((name, index)=>{
        const r = netResults[name] || {points: [], total:0, cuts: [], net:0};
        html += `<tr><td>${index+1}</td><td>${name}</td>`;
        r.points.forEach(p => { html += `<td>${p === seriesCount + 1 ? '<span class="dns">'+p+'</span>' : p}</td>`; });
        html += `<td>${r.total}</td>`;
        for(let i=0;i<maxCut;i++){ html += `<td>${r.cuts[i] !== undefined ? '<span class="cut">'+r.cuts[i]+'</span>': ''}</td>`; }
        html += `<td>${r.net}</td></tr>`;
    });

    document.getElementById('tableContainer').innerHTML = "<div class='table-wrapper'>"+html+"</div>";
}

// ---------- ヒート削除 ----------
function deleteHeat(index){
    if(!confirm(`"${heats[index]}" を削除しますか？`)) return;
    heats.splice(index,1);
    // 各選手の配列から該当インデックスをsplice
    for(const name in results){
        if(results[name] && results[name].length > index) results[name].splice(index,1);
    }
    updateTable();
}

// ---------- 順位ソート（Net値基準） ----------
// タイブレークルールは提供のまま（yacht / wind 切替）
function sortTableByColumn(colIndex){
    if(colIndex !== 0) return;
    const netResults = calculateNetPoints();
    const discipline = document.getElementById('discipline').value;
    displayOrder.sort((a,b)=>{
        const rA = netResults[a], rB = netResults[b];
        const netDiff = rA.net - rB.net;
        if(netDiff !== 0) return currentSortAsc ? netDiff : -netDiff;

        // タイブレーク
        let tieBreakResult = 0;
        if(discipline === 'yacht'){
            tieBreakResult = compareArrays(rA.keptPoints, rB.keptPoints);
            if(tieBreakResult !== 0) return currentSortAsc ? tieBreakResult : -tieBreakResult;
            const keptReversedA = rA.points.filter((p,i)=> rA.cuts.indexOf(p) === -1).reverse();
            const keptReversedB = rB.points.filter((p,i)=> rB.cuts.indexOf(p) === -1).reverse();
            tieBreakResult = compareArrays(keptReversedA, keptReversedB);
            if(tieBreakResult !== 0) return currentSortAsc ? tieBreakResult : -tieBreakResult;
        } else if(discipline === 'wind'){
            tieBreakResult = compareArrays(rA.cutsSorted, rB.cutsSorted);
            if(tieBreakResult !== 0) return currentSortAsc ? tieBreakResult : -tieBreakResult;
            tieBreakResult = compareArrays(rA.allPointsSorted, rB.allPointsSorted);
            if(tieBreakResult !== 0) return currentSortAsc ? tieBreakResult : -tieBreakResult;
            const keptReversedA = rA.points.filter((p,i)=> rA.cuts.indexOf(p) === -1).reverse();
            const keptReversedB = rB.points.filter((p,i)=> rB.cuts.indexOf(p) === -1).reverse();
            tieBreakResult = compareArrays(keptReversedA, keptReversedB);
            if(tieBreakResult !== 0) return currentSortAsc ? tieBreakResult : -tieBreakResult;
        }
        // 完全同点は選手番号で安定ソート
        return currentSortAsc ? a.localeCompare(b) : b.localeCompare(a);
    });
    updateTable();
    currentSortAsc = !currentSortAsc;
}

function compareArrays(arrA, arrB){
    const len = Math.max(arrA.length, arrB.length);
    for(let i=0;i<len;i++){
        const valA = arrA[i] !== undefined ? arrA[i] : Infinity;
        const valB = arrB[i] !== undefined ? arrB[i] : Infinity;
        if(valA !== valB) return valA - valB;
    }
    return 0;
}

// ---------- CSV出力 ----------



function downloadCSV() {
    // ファイル名を入力
    let filename = prompt("保存するファイル名（.csv は自動で付きます）", "result");
    if (!filename) return;

    if (!filename.toLowerCase().endsWith(".csv")) {
        filename += ".csv";
    }

    // CSV生成
    let csv = "";
    try {
        csv = generateCSV();
    } catch (e) {
        alert("CSV生成中にエラーが発生しました");
        console.error(e);
        return;
    }

    if (!csv) {
        alert("出力するCSVデータがありません");
        return;
    }

    // Blob を使って確実にダウンロード
    const blob = new Blob([csv], { type: "text/csv;charset=utf-8;" });
    const url = URL.createObjectURL(blob);

    const a = document.createElement("a");
    a.href = url;
    a.download = filename;

    // これを使うと確実に動く
    document.body.appendChild(a);
    a.click();
    document.body.removeChild(a);

    URL.revokeObjectURL(url);
}











// 初期化：空状態で表示（必要ならここでデフォルトデータを入れる）
applyParticipantsFromInput();
updateTable();

</script>
</body>
</html>
